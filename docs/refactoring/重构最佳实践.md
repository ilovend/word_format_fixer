# 重构最佳实践指南

## 概述

本指南基于 Word Format Fixer 项目的重构经验，总结了在 AI 辅助重构过程中的最佳实践、常见陷阱和检查清单。

---

## 核心原则

### 1. 全局视角原则

**原则**: 重构必须考虑全局影响，不能只关注局部修改。

**实践**:
- 在修改任何代码前，先找出所有依赖它的地方
- 使用 IDE 的"查找引用"功能列出所有引用
- 创建受影响文件清单

**示例**:
```bash
# 查找所有引用 FontStandardRule 的地方
grep -r "FontStandardRule" --include="*.py" .
grep -r "FontStandardRule" --include="*.js" .
grep -r "FontStandardRule" --include="*.html" .
```

**检查清单**:
- [ ] 列出所有依赖当前模块的文件
- [ ] 列出所有使用当前模块功能的文件
- [ ] 列出所有需要同步修改的配置文件
- [ ] 列出所有需要同步更新的文档

---

### 2. 同步修改原则

**原则**: 前后端共享数据模型，修改一端必须同步修改另一端。

**实践**:
- 修改后端 API 时，同步更新前端调用
- 修改数据结构时，同步更新所有使用该结构的地方
- 使用 API 契约来确保一致性

**示例**:
```python
# 后端修改规则 ID
class FontStandardRule:
    rule_id = "FontStandardRule"  # 旧ID

# 拆分为
class FontNameRule:
    rule_id = "FontNameRule"  # 新ID1

class FontSizeRule:
    rule_id = "FontSizeRule"  # 新ID2

# 必须同步更新
# 1. config/presets.yaml 中的规则引用
# 2. 前端 electron/index.html 中的预设数据
# 3. 前端 electron/index.html 中的规则分类逻辑
```

**检查清单**:
- [ ] 后端 API 接口变更了吗？
- [ ] 后端返回数据结构变更了吗？
- [ ] 前端调用的数据结构需要更新吗？
- [ ] 前端 UI 显示需要更新吗？
- [ ] 预设配置需要更新吗？

---

### 3. 功能完整性原则

**原则**: 功能必须端到端完整实现，不能只实现部分。

**实践**:
- 实现服务层后，必须实现对应的 API 层
- 实现 API 层后，必须实现对应的 UI 层
- 每一层都要有对应的测试

**示例**:
```python
# ❌ 错误：只实现了服务层
class ConfigManagementService:
    def save_preset(self, preset_id, preset_data):
        # 实现了保存逻辑
        pass

# ✅ 正确：完整实现三层
# 服务层
class ConfigManagementService:
    def save_preset(self, preset_id, preset_data):
        return self.repository.save_preset(preset_id, preset_data)

# API 层
def do_POST(self):
    if self.path == '/api/presets/save':
        request_data = json.loads(self.rfile.read())
        result = config_service.save_preset(
            request_data['preset_id'],
            request_data['preset_data']
        )
        self._send_response(200, result)

# UI 层
function savePreset() {
    const presetId = document.getElementById('presetId').value;
    const presetData = getPresetData();
    await window.electronAPI.savePreset(presetId, presetData);
}
```

**检查清单**:
- [ ] 服务层实现了吗？
- [ ] API 层暴露接口了吗？
- [ ] 前端调用方法添加了吗？
- [ ] 前端 UI 实现了吗？
- [ ] 端到端测试通过了吗？

---

### 4. 路径可靠性原则

**原则**: 路径计算必须可靠，避免使用容易出错的相对路径。

**实践**:
- 优先使用绝对路径
- 使用 pathlib 库而非 os.path
- 通过环境变量或配置文件指定路径
- 避免使用 `__file__` 进行多层相对路径计算

**示例**:
```python
# ❌ 错误：多层相对路径计算，容易出错
PORT_FILE_PATH = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
    '.port'
)

# ✅ 正确：使用 pathlib
from pathlib import Path
BASE_DIR = Path(__file__).parent.parent.parent
PORT_FILE_PATH = BASE_DIR / '.port'

# ✅ 正确：使用环境变量
import os
BASE_DIR = Path(os.getenv('PROJECT_ROOT', '.'))
PORT_FILE_PATH = BASE_DIR / '.port'

# ✅ 正确：使用配置文件
import yaml
with open('config/app_config.yaml') as f:
    config = yaml.safe_load(f)
BASE_DIR = Path(config['base_dir'])
PORT_FILE_PATH = BASE_DIR / config['port_file']
```

**检查清单**:
- [ ] 使用 pathlib 而非 os.path 吗？
- [ ] 避免了多层相对路径计算吗？
- [ ] 路径可以配置吗？
- [ ] 测试了不同位置的文件路径吗？

---

### 5. 测试验证原则

**原则**: 每次重构后必须进行充分的测试验证。

**实践**:
- 修改代码后立即测试
- 运行所有相关测试
- 进行端到端功能测试
- 检查控制台错误

**示例**:
```bash
# 测试脚本
#!/bin/bash
echo "开始重构后测试..."

# 1. 检查 Python 语法
python -m py_compile python-backend/**/*.py
if [ $? -ne 0 ]; then
    echo "❌ Python 语法错误"
    exit 1
fi

# 2. 启动后端服务
cd python-backend
python main.py &
BACKEND_PID=$!
sleep 3

# 3. 测试 API 端点
curl http://localhost:7777/api/health
if [ $? -ne 0 ]; then
    echo "❌ 健康检查失败"
    kill $BACKEND_PID
    exit 1
fi

# 4. 测试规则 API
curl http://localhost:7777/api/rules
if [ $? -ne 0 ]; then
    echo "❌ 规则 API 失败"
    kill $BACKEND_PID
    exit 1
fi

# 5. 测试预设 API
curl http://localhost:7777/api/presets
if [ $? -ne 0 ]; then
    echo "❌ 预设 API 失败"
    kill $BACKEND_PID
    exit 1
fi

# 6. 清理
kill $BACKEND_PID

echo "✅ 所有测试通过"
```

**检查清单**:
- [ ] 后端能启动吗？
- [ ] 所有 API 端点都能访问吗？
- [ ] 前端能启动吗？
- [ ] 所有前端功能都能使用吗？
- [ ] 端到端功能测试通过了吗？
- [ ] 没有控制台错误吗？

---

## 重构工作流程

### 阶段 1: 规划阶段

**目标**: 明确重构目标，制定详细计划。

**步骤**:

1. **明确重构目标**
   ```
   为什么要重构？
   - 解决架构问题
   - 提升代码质量
   - 添加新功能
   ```

2. **分析影响范围**
   ```bash
   # 查找所有引用
   grep -r "类名/函数名" --include="*.py" .
   grep -r "类名/函数名" --include="*.js" .
   grep -r "类名/函数名" --include="*.html" .
   ```

3. **列出文件清单**
   ```
   需要修改的文件：
   - python-backend/rules/font_rules/font_standard_rule.py
   - python-backend/rules/paragraph_rules/title_alignment_rule.py
   - ...

   受影响的文件：
   - python-backend/rules/__init__.py
   - config/presets.yaml
   - electron/index.html
   - ...
   ```

4. **制定测试计划**
   ```
   - 单元测试
   - 集成测试
   - 端到端测试
   ```

**检查清单**:
- [ ] 重构目标明确吗？
- [ ] 影响范围分析完整吗？
- [ ] 文件清单列全了吗？
- [ ] 测试计划制定了吗？

---

### 阶段 2: 实施阶段

**目标**: 按照计划实施修改。

**步骤**:

1. **修改核心文件**
   ```
   - 实现核心逻辑
   - 添加必要的注释
   - 遵循编码规范
   ```

2. **同步修改受影响的文件**
   ```
   - 更新引用
   - 更新配置
   - 更新文档
   ```

3. **检查引用关系**
   ```bash
   # 验证没有遗漏的引用
   grep -r "旧类名" --include="*.py" .
   ```

**检查清单**:
- [ ] 核心文件修改完成了吗？
- [ ] 受影响的文件都更新了吗？
- [ ] 配置文件更新了吗？
- [ ] 没有遗漏的旧引用吗？

---

### 阶段 3: 验证阶段

**目标**: 验证修改的正确性。

**步骤**:

1. **运行代码静态检查**
   ```bash
   # Python
   python -m py_compile python-backend/**/*.py
   flake8 python-backend/

   # JavaScript
   eslint electron/**/*.js
   ```

2. **运行单元测试**
   ```bash
   pytest tests/
   ```

3. **启动后端服务**
   ```bash
   cd python-backend
   python main.py
   ```

4. **测试所有 API 端点**
   ```bash
   curl http://localhost:7777/api/health
   curl http://localhost:7777/api/rules
   curl http://localhost:7777/api/presets
   ```

5. **启动前端应用**
   ```bash
   cd electron
   npm start
   ```

6. **测试所有 UI 功能**
   ```
   - 文件选择
   - 规则启用/禁用
   - 预设选择
   - 文档处理
   ```

7. **进行端到端测试**
   ```
   - 完整的用户流程
   - 边界情况
   - 错误处理
   ```

**检查清单**:
- [ ] 静态检查通过了吗？
- [ ] 单元测试通过了吗？
- [ ] 后端能启动吗？
- [ ] 所有 API 端点都能访问吗？
- [ ] 前端能启动吗？
- [ ] 所有前端功能都能使用吗？
- [ ] 端到端测试通过了吗？
- [ ] 没有控制台错误吗？

---

### 阶段 4: 文档阶段

**目标**: 更新相关文档。

**步骤**:

1. **更新 API 文档**
   ```
   - 新增的 API 接口
   - 修改的 API 接口
   - 废弃的 API 接口
   ```

2. **更新架构文档**
   ```
   - 架构变更说明
   - 新增的组件
   - 修改的组件
   - 数据流变化
   ```

3. **更新使用文档**
   ```
   - 新功能使用说明
   - 功能变更说明
   - 配置变更说明
   ```

4. **记录变更日志**
   ```
   - 新增功能
   - 修改功能
   - 修复问题
   - 破坏性变更
   ```

**检查清单**:
- [ ] API 文档更新了吗？
- [ ] 架构文档更新了吗？
- [ ] 使用文档更新了吗？
- [ ] 变更日志记录了吗？

---

## 常见陷阱和解决方案

### 陷阱 1: 只修改部分文件

**现象**:
- 修改了后端，但没修改前端
- 修改了服务层，但没修改 API 层

**解决方案**:
- 使用"影响范围分析"列出所有需要修改的文件
- 使用检查清单确保所有文件都已修改

---

### 陷阱 2: 路径计算错误

**现象**:
- 配置文件找不到
- 相对路径计算错误

**解决方案**:
- 使用 pathlib 库
- 避免多层相对路径计算
- 使用环境变量或配置文件

---

### 陷阱 3: 规则 ID 不一致

**现象**:
- 前端使用的规则 ID 在后端不存在
- 后端返回的规则 ID 前端无法识别

**解决方案**:
- 使用 API 契约确保一致性
- 前后端共享规则定义
- 进行一致性检查

---

### 陷阱 4: 没有测试就提交

**现象**:
- 代码提交后才发现错误
- 需要回滚修改

**解决方案**:
- 建立强制测试流程
- 使用自动化测试
- 进行代码审查

---

### 陷阱 5: 文档不更新

**现象**:
- 代码和文档不一致
- 新人难以理解系统

**解决方案**:
- 将文档更新作为重构的一部分
- 使用变更日志记录变更
- 定期审查文档准确性

---

## 工具推荐

### 1. 代码分析工具
- **grep**: 查找引用
- **ripgrep (rg)**: 更快的代码搜索
- **codemap**: 可视化代码依赖

### 2. 测试工具
- **pytest**: Python 单元测试
- **jest**: JavaScript 单元测试
- **pytest-cov**: 代码覆盖率

### 3. 静态检查工具
- **flake8**: Python 代码检查
- **pylint**: Python 代码质量
- **eslint**: JavaScript 代码检查
- **mypy**: Python 类型检查

### 4. API 测试工具
- **curl**: 命令行 HTTP 客户端
- **Postman**: API 测试界面
- **httpie**: 友好的 HTTP 客户端

### 5. 文档工具
- **Sphinx**: Python 文档生成
- **JSDoc**: JavaScript 文档生成
- **Swagger/OpenAPI**: API 文档

---

## 总结

重构是一个系统的工程活动，需要遵循以下原则：

1. **全局视角**: 考虑修改的全局影响
2. **同步修改**: 前后端保持一致
3. **功能完整**: 端到端完整实现
4. **路径可靠**: 使用可靠的路径计算
5. **充分测试**: 修改后必须测试

遵循这些原则和最佳实践，可以大大减少重构过程中的错误，提高代码质量和重构效率。

---

**文档版本**: 1.0
**创建日期**: 2026-01-22
**维护者**: ilovend
