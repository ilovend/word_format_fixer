# 架构改进对比图

## 重构前的架构问题

### 问题1: 规则职责混杂
```
FontStandardRule (单体类)
├── 字体标准化 (职责1)
├── 标题格式化 (职责2)
├── 字号标准化 (职责3)
└── 标题样式应用 (职责4)

问题:
❌ 违反单一职责原则
❌ 难以禁用特定功能
❌ 配置混乱
❌ 测试困难
```

### 问题2: 规则间隐式依赖
```
PageLayoutRule
├── 设置页面布局
└── 修改 context.available_width_cm ← 破坏封装

TableWidthRule
└── 依赖 context.available_width_cm ← 隐式依赖

问题:
❌ 规则执行顺序固定
❌ 无法独立执行
❌ 违反规则独立性原则
```

### 问题3: IPC 层包含业务逻辑
```
IPC Adapter (HTTP 处理器)
├── HTTP 请求解析 (基础设施)
├── 参数验证 (业务逻辑) ← 不应该在这里
├── 规则执行编排 (业务逻辑) ← 不应该在这里
├── 业务规则验证 (业务逻辑) ← 不应该在这里
└── HTTP 响应构建 (基础设施)

问题:
❌ 分层混乱
❌ 业务逻辑无法复用
❌ 难以测试
❌ 违反架构约束
```

### 问题4: ConfigLoader 职责混杂
```
ConfigLoader
├── 配置加载/合并 (业务逻辑)
├── YAML 序列化 (基础设施)
├── 文件 I/O (基础设施)
└── 业务规则验证 (业务逻辑)

问题:
❌ 违反单一职责原则
❌ 测试困难
❌ 难以扩展到数据库
```

### 问题5: 端口管理重复
```
后端 (python-backend/ipc/adapter.py)
└── find_available_port() ← 端口发现逻辑

前端 (electron/main.js)
└── getApiPort() ← 端口发现逻辑 (重复)

问题:
❌ 代码重复 (DRY 违反)
❌ 前端硬编码端口列表
❌ 耦合度高
```

### 问题6: 前端预设数据重复
```
后端 (config/presets.yaml)
└── 预设数据

前端 (electron/index.html)
└── 预设数据 (重复)

问题:
❌ 数据重复
❌ 容易不一致
❌ 难以维护
```

---

## 重构后的架构

### 1. 规则单一职责
```
FontNameRule
├── 职责: 字体名称标准化
└── 独立配置: chinese_font, western_font

TitleFontRule
├── 职责: 标题字体设置
└── 独立配置: title_font

FontSizeRule
├── 职责: 字号标准化
└── 独立配置: font_size_body, font_size_title1/2/3

TitleAlignmentRule
├── 职责: 标题对齐设置
└── 独立配置: heading1_align, other_heading_align

TitleBoldRule
├── 职责: 标题加粗
└── 独立配置: bold

收益:
✓ 单一职责
✓ 可独立启用/禁用
✓ 配置清晰
✓ 易于测试
```

### 2. 规则独立性
```
PageLayoutRule
└── 只负责设置页面布局 (不修改上下文)

TableWidthRule
└── 从文档直接计算可用宽度 (不依赖上下文)

收益:
✓ 规则可独立执行
✓ 无执行顺序依赖
✓ 更清晰的职责
```

### 3. 清晰的分层架构
```
┌─────────────────────────────────────────┐
│  Presentation Layer                      │
│  (Electron UI)                           │
│  - UI 渲染                               │
│  - 用户交互                               │
└──────────────────┬──────────────────────┘
                   │ HTTP
┌──────────────────▼──────────────────────┐
│  IPC Layer (adapter.py)                   │
│  - HTTP 请求/响应处理                      │
│  - 协议转换                                │
│  - 无业务逻辑 ✓                           │
└──────────────────┬──────────────────────┘
                   │ 调用服务
┌──────────────────▼──────────────────────┐
│  Application Service Layer                │
│                                          │
│  DocumentProcessingService               │
│  └── process_document()                  │
│                                          │
│  ConfigManagementService                 │
│  ├── get_all_presets()                   │
│  ├── save_preset()                       │
│  └── delete_preset()                     │
│                                          │
│  RuleManagementService                   │
│  └── get_all_rules()                     │
└──────────────────┬──────────────────────┘
                   │ 调用引擎
┌──────────────────▼──────────────────────┐
│  Domain Layer                            │
│                                          │
│  RuleEngine                              │
│  ├── execute()                           │
│  ├── register_rule()                     │
│  └── get_rules_info()                    │
│                                          │
│  BaseRule (抽象基类)                      │
│  ├── apply()                             │
│  └── get_metadata()                      │
│                                          │
│  具体规则 (独立、可测试)                   │
│  ├── FontNameRule                        │
│  ├── TitleFontRule                       │
│  ├── FontSizeRule                        │
│  ├── TitleAlignmentRule                  │
│  ├── TitleBoldRule                       │
│  ├── FontColorRule                       │
│  ├── ParagraphSpacingRule                │
│  ├── ListNumberingRule                   │
│  ├── TableWidthRule                      │
│  ├── TableBorderRule                     │
│  └── PageLayoutRule                      │
└──────────────────┬──────────────────────┘
                   │ 依赖接口
┌──────────────────▼──────────────────────┐
│  Infrastructure Layer                    │
│                                          │
│  IConfigRepository (接口)                │
│  ├── load_config()                       │
│  ├── save_config()                       │
│  ├── get_preset()                        │
│  └── delete_preset()                     │
│                                          │
│  YamlConfigRepository (实现)              │
│  └── 纯数据操作 ✓                         │
│                                          │
│  PortManager                             │
│  ├── find_available_port()               │
│  ├── get_port()                          │
│  └── 端口文件管理                          │
└─────────────────────────────────────────┘

收益:
✓ 分层清晰
✓ 职责明确
✓ 业务逻辑可复用
✓ 易于测试
✓ 符合架构约束
```

### 4. 配置管理分离
```
IConfigRepository (接口)
├── load_config()
├── save_config()
├── get_preset()
├── delete_preset()
└── save_preset()

        ↑ 依赖
        |
ConfigLoader (业务逻辑)
├── get_preset()
├── get_all_presets()
├── load_preset_config()
├── get_enabled_rules()
├── save_preset() → 委托给 Repository
└── delete_preset() → 委托给 Repository

        ↑ 依赖
        |
YamlConfigRepository (持久化)
├── 纯数据操作 ✓
├── YAML 文件 I/O
└── 无业务逻辑

收益:
✓ 依赖倒置
✓ 易于测试
✓ 易于扩展到数据库
✓ 职责清晰
```

### 5. 统一的端口管理
```
PortManager (统一管理)
├── find_available_port()
├── get_port()
├── _write_port_to_file()
└── _read_port_from_file()

        ↑ 使用
        |
后端 (启动时)
├── port_manager.find_available_port()
└── 写入 .port 文件

        ↑ 读取
        |
前端 (连接时)
├── port_manager.get_port()
└── 从 .port 文件读取

收益:
✓ 消除代码重复
✓ 前后端解耦
✓ 可靠的端口传递
✓ 易于扩展
```

### 6. 预设数据单一数据源
```
后端 (唯一数据源)
├── config/presets.yaml
└── ConfigManagementService
    ├── get_all_presets()
    ├── save_preset()
    └── delete_preset()

        ↑ API
        |
前端 (从后端获取)
├── fetchPresetsFromBackend()
└── 显示预设

        ↑ 元数据
        |
规则分类
├── 从后端元数据读取 category
└── 动态生成 UI

收益:
✓ 单一数据源
✓ 数据一致性
✓ 易于维护
✓ 元数据驱动
```

---

## 数据流对比

### 重构前 (混乱的数据流)
```
前端
  ↓ HTTP (包含业务逻辑验证)
IPC Adapter (包含业务逻辑)
  ↓ 直接调用
RuleEngine
  ↓
RuleContext (被修改)
  ↓
Rules (有隐式依赖)
```

### 重构后 (清晰的分层流)
```
前端
  ↓ HTTP (纯协议转换)
IPC Adapter
  ↓ 调用服务
Application Services
  ├── DocumentProcessingService
  ├── ConfigManagementService
  └── RuleManagementService
  ↓ 调用引擎/仓库
Domain Layer
  ├── RuleEngine
  ├── Rules (独立)
  └── ConfigLoader
  ↓ 依赖接口
Infrastructure Layer
  ├── YamlConfigRepository
  └── PortManager
```

---

## 依赖关系对比

### 重构前
```
IPC Adapter
├── 依赖: RuleEngine (直接调用)
├── 依赖: ConfigLoader (直接调用)
└── 耦合: 紧耦合 (直接依赖具体实现)

TableWidthRule
└── 隐式依赖: PageLayoutRule (必须先执行)

前端
├── 依赖: 硬编码的端口列表
└── 依赖: 重复的预设数据
```

### 重构后
```
IPC Adapter
├── 依赖: Application Services (接口)
├── 耦合: 松耦合 (依赖抽象)
└── 职责: 纯协议转换

所有 Rules
└── 无依赖 (完全独立)

前端
├── 依赖: 端口文件 (统一管理)
└── 依赖: 后端 API (单一数据源)
```

---

## 设计原则对比

### 重构前
| 原则 | 遵守情况 | 问题 |
|------|----------|------|
| 单一职责原则 | ❌ | FontStandardRule 职责过多 |
| 开闭原则 | ⚠️ | 扩展需要修改现有代码 |
| 依赖倒置原则 | ❌ | 直接依赖具体实现 |
| 接口隔离原则 | ❌ | 没有接口抽象 |
| DRY 原则 | ❌ | 端口管理和预设数据重复 |

### 重构后
| 原则 | 遵守情况 | 改进 |
|------|----------|------|
| 单一职责原则 | ✅ | 每个类职责明确 |
| 开闭原则 | ✅ | 通过接口易于扩展 |
| 依赖倒置原则 | ✅ | 高层依赖抽象接口 |
| 接口隔离原则 | ✅ | 细粒度的服务接口 |
| DRY 原则 | ✅ | 消除了代码重复 |

---

## 架构约束遵循对比

### 重构前
| 约束 | 遵守情况 | 问题 |
|------|----------|------|
| 规则引擎定位 | ❌ | IPC 层包含业务逻辑 |
| 无 utils/models/helpers | ⚠️ | 虽然没有但职责不清 |
| 规则独立 | ❌ | 规则间有隐式依赖 |
| FastAPI 仅用于 IPC | ⚠️ | 虽然没使用 Web 特性但包含业务逻辑 |

### 重构后
| 约束 | 遵守情况 | 改进 |
|------|----------|------|
| 规则引擎定位 | ✅ | 业务逻辑在服务和规则层 |
| 无 utils/models/helpers | ✅ | 使用了 services 和 infrastructure |
| 规则独立 | ✅ | 规则完全独立可执行 |
| FastAPI 仅用于 IPC | ✅ | IPC 层纯粹做协议转换 |

---

## 总结

通过本次重构，项目从"功能混杂、职责不清"的状态，转变为"分层清晰、职责明确"的架构：

### 核心改进
1. **单一职责**: 每个类只负责一个职责
2. **分层清晰**: 展示层 → IPC 层 → 服务层 → 领域层 → 基础设施层
3. **依赖倒置**: 高层依赖抽象，低层实现抽象
4. **消除重复**: 端口管理和预设数据统一管理
5. **规则独立**: 规则之间无隐式依赖

### 架构收益
- **可维护性**: 清晰的分层和职责
- **可测试性**: 每层可以独立测试
- **可扩展性**: 基于接口的设计
- **可复用性**: 业务逻辑可以在不同场景复用

### 遵循约束
- **规则引擎定位**: 保持核心定位不变
- **架构约束**: 严格遵守项目架构方案
- **设计原则**: 全面应用 SOLID 和 DRY 原则
